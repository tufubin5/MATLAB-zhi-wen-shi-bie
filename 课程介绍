指纹识别技术文档

1指纹识别的引入和原理

1.1 指纹的基本知识

指纹是我们各个手指的第一个指节的指头表面突起的脊线；而脊线是手指突起的花脊线条；谷线是两个脊线之间低凹下去的部分；指印是指纹在物体表面留下的痕迹；指纹的细节特征是指纹固有的自身特点。根据指纹中的细节特征我们常将指纹特点分为端点和分叉点，如图1-1所示。

图1-1  端点、分叉点

1.2 指纹识别的原理及算法流程

在指纹识别的技术中, 一般都采用总体特征和局部特征来进行识别。总体特征是那些很容易就能看出来的非常明显的特征, 局部特征则是一小块指纹中的细节特征。指纹纹路一般都会有断点和分叉点, 因此会形成一些独特的节点。根据研究，两个指纹的总体特征有时候会很相似，但是局部特征是不会相同的，即没有两个指纹的纹路是相同的。英国学者E.G.Herry认为, 只要有13个特征点能重合, 就可以确认这两枚指纹是同一指纹[3]。指纹的面积虽然不大但却蕴含着大量的识别信息。这些皮肤的纹路会在交叉点，断点上有很大的区别。在指纹识别的过程中将其称为“特征点”，利用特征点的性质，我们可以把一个人的指纹同预先存储起来的指纹模版对比来验证他的真实身份。
指纹识别技术主要包括三大部分：指纹图像采集、指纹预处理、特征提取与匹配。如图1-4所示。
        图1-2  指纹识别流程


2 指纹图像预处理

图像预处理是对原始图像进行的一种前期处理，方便后续的模块识别。无论采用何种方式获取的指纹图像, 都有一部分由于质量原因, 不能被系统直接识别，因此图像的预处理就显得非常有必要。
指纹图像的预处理目的就是将自己感兴趣的目标区域保留下来，去除背景区域和没有用的部分，同时根据指纹目标区域中脊线的结构特征，采取较好的滤波方法，提高指纹脊线清晰度，平滑脊线边缘的毛刺和空洞，抑制图像噪声，保证指纹特征的可靠提取，并使灰度图像转化成黑白的二值图像，最终得到脊线结构清晰的单像素宽的二值图像。本文预处理的主要流程如图2-1所示。



图2-1  预处理流程
                                    
2.1 指纹图像的采集

   因本设计重点是对指纹图像的处理，最终得到匹配结果，因此指纹图像的获取并非本设计的重点。指纹图像的获取可以借助市面上的指纹采集器货得，或者自行利用手机和数码相机等拍摄器材采集。

2.2图像的灰度处理

将彩色图转化成为灰度图的过程称为图像的灰度化处理。彩色图像中的每个像素的颜色有R、G、B三个分量决定，而每个分量有255个中值可取，这样一个像素点可以有1600多万（255*255*255）的颜色的变化范围。而灰度图像是R、G、B三个分量相同的一种特殊的彩色图像，其中一个像素点的变化范围为255种，所以在数字图像处理中一般先将各种格式的图像转变成灰度图像以使后续的图像的计算量变得少一些。灰度图像的描述与彩色图像一样仍然反映了整幅图像的整体和局部的色度和亮度等级的分布和特征。在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫做灰度值。因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255。
在MATLAB中，调用库函数rgb2gray进行彩色图像转灰度图像的处理，调用格式为：I=rgb2gray（image），其中image为彩色图像，I为处理后的灰度图像。以下为处理的图。
    
            原指纹图像                               灰度图像

2.3 图像的二值化

二值化就是将图像上的像素点的灰度值设置为0或1，也就是将整个图像呈现出明显的黑白视觉效果。指纹图像中包括目标和背景还有众多噪声，要想从原始的指纹图像中提取出目标，一般用的方法是设定一个阈值T，用T将图像中像素数据分成两部分，若输入灰度图像的函数为： 
                       （2-4）
通过求解阈值T，从而把图像f(x,y)分成目标和背景两个区域，其中大于T的像素群为目标区域，小于等于T的像素群为背景区域，阈值的选取原则是：（1）尽可能的多保存图像信息；（2）尽可能的减少噪声。
本文将讨论基于方向场的二值化处理。
采集到的指纹图像一般都有比较清晰的方向场，方向场估计得准确与否直接决定了图像二值化算法的效果。
为估计方向场，我们把指纹脊线的走向分为如下8个方向，如图2-6所示：

图 2-6  一个像素处的8个指纹脊线方向
我们先对分割后的图像进行了平均滤波，然后对图像的每一个像素，为确定在该像素处的脊线方向，在以该像素为中心的9*9窗口内，分别计算8个方向上的经过处理后的灰度值，即将图2-6中数字1到8的位置的像素灰度值去除其中最大summax和最小值summin，若满足最大的summax和最小的summin与 4*I(x,y))之和大于 (3*summ/8),则该像素点的脊线方向为summin,否则为summax.确定完脊线方向后再由该方向场对图像进行二值化。
结果如下：

图 2-7  指纹二值化

2.4 图像细化

二值化处理后，脊线仍然有一定的宽度，指纹识别的匹配是只利用图像的点或线的特征，这些点或者特征只与脊线的走向或者纹理有关系，有一定宽度的二值化图像显得有些多余，所以需要对二值化图像进行细化处理，指纹二值化图像经过细化处理即可得到一个单一像素宽度的脊线，经过上述的细化处理，在后续的指纹特征提取和特征匹配的算法中大大的减少了计算的冗余量和出错率，使得指纹识别的速度和准确度有了很大的提高。
细化目的是在不破坏指纹图像连通性的情况下去除掉多余的信息（即多余的像素点），将二值化的指纹图像的脊线采用逐层剥离的方法，将图像中的指纹脊线细化成单象素宽（实际为保存原图的骨架）。
这里是利用matlab库函数bwmorph，调用格式为：BW2 = bwmorph(BW,operation,n)应用形态学操作n次，n可以是Inf，这种情况下该操作被重复执行直到图像不再发生变化为止。
'thin'	n = Inf时，减薄目标成线。没有孔洞的目标缩成最低限度的连通边；有孔洞的目标缩成连通环。
参考连接：https://blog.csdn.net/a1075863454/article/details/45646187


 3 图像特征提取和特征匹配
 
3.1 特征点提取

（1）提取指纹的端点和交叉点
端点和交叉点均是指纹图像的两个细节特征，同时在指纹识别的的过程中起着重要的作用，因为识别的首要前提就是找到图像的所有端点和交叉点。通过point.m函数来找出细化后指纹图像的所有端点及交叉点。
将八邻域中的每个点依次两两相减并取其绝对值，后将所有结果加起来，因为端点处是两个点，即和为2时细化图像有端点，和为6时图像特征为交叉点。
运行完上面的point.m函数的程序后，能把细化图像的的端点和交叉点全部找出。在定义函数的程序中有数组txy，其中t为横坐标，x为纵坐标，y为2时为端点，y为6时为交叉点。
（2）去除图像边缘的端点[去伪]
可以看出，指纹图像细化的边缘，由于采集仪器不同的关系，因此不可避免的会多出很多的端点，这些端点不仅增加了后续的工作量，还可能导致识别过程中产生错误，所以要把这些边缘的端点都去除，在matlab中这些操作都可以采用一函数来实现，本实验中设计了一cut.m函数来进行处理。

3.2 找出特征点

设置三个函数来找出图像的特征点：
（1）single_point函数
	 经过去除边缘端点的操作后进一步减少了指纹细化图像中的端点和交叉点的个数。下面就需要找出一些在细化图像中比较独特的端点来作为识别的特征点。在一幅细化的指纹图像中，如果在一个像素（该像素为端点）的周围半径为r（r为像素的个数）的圆内没有任何的端点或者交叉点，那么随着r的逐渐增大，这样的点就会越来越少，因此该点也就越来越独特。于是我们设计了一single_point函数来找出这样独特的点。
（2）walk函数
为了进一步找出特征点，我们还需定义一walk函数，它的主要作用就是判断某一端点在num的距离内是否还有其他的端点。
（3）last1函数
single_point函数和walk函数都是找细化图像特征点的函数，因此可以设计另一个新的last1函数，通过执行
[pxy3,error2]=last1(thin,r,txy,num)
可以找出一端点以r为半径的像素内的任何端点和交叉点且沿着脊线走向的num内没有任何的其他端点和交叉点。

3.3 特征点匹配

由上文的函数可知，已经找出了指纹细化图像中的特征点，并画出了一段独特的脊线，在图像中用红色来标示。下面就是指纹匹配[12]的问题了。在此我们设置了三层匹配。
（1）脊线长度匹配
对于上面的函数即可找出细化图像中的特征点和一段脊线，沿着该段脊线走向，每隔五个像素测量一下，看到到原始端点的距离，此段距离由一distance函数得到。
函数结果会得到一数组（内有脊线的长度信息）。如果两幅指纹细化图像中的纹路是相同的，则它们就包含相同的端点和交叉点及用distance函数找出的相同的一段脊，则这两个指纹图像中的长度数组对应的位置比例会基本相等（我们选择的指纹图像大小基本相等，因此该比例选1），因此函数最终定义了一个数f=(sum(abs((d1./d2)-1)))，其中若f的值越接近于0，这两幅图像的匹配度就越高，在一定范围的阈值内我们可以认定为匹配。
（2）三角形边长匹配
找到一个指纹细化图像的特征点后，可以找出距离这个端点距离最近的两个端点或者交叉点，与这个指纹图像细化的特征点构成一个三角形，若两幅图像中的边长比例基本相等（原理同上，也选1），则说明这两幅图像匹配，越接近于1说明这两幅指纹图像越匹配。其中设置一find_point函数来找出距离最近的端点或交叉点。
函数最后定义了一个数ff=(sum(abs((dd1./dd2)-1)))，因此ff值越接近于0，这两幅指纹图像的匹配度越高，在一定范围的阈值内我们可以认定为匹配。
（3）点类型匹配
找到一个指纹细化图像的特征点后，在该端点周围找到四十个端点或者交叉点，统计在这四十个特征点中端点的个数和交叉点的个数。若有两幅指纹细化图像中的端点所占的比例近似相同，则两幅图像相匹配，越近似，则越相同。函数最终定义了一个数fff=abs(f11-f21)/(f11+f12)，所以fff值越接近于0，这两幅指纹图像的匹配度就会越高。我们也设定一阈值，在此阈值内都可以认定为匹配。
本文中取r=8，num=60，经过试验，得到f的阈值为0.5，ff的阈值为1.5，fff的阈值为0.2。即两幅图像的f，ff，fff若均小于阈值，则两幅图匹配；若三个值中有至少一个值大于阈值，则不匹配。验证如下：
一、选择两幅图：101_1.tif和101_2.tif验证,结果如下：

图 3-1 输出的结果
通过以上的f，ff，fff和阈值的比较说明101_1.tif和101_2.tif匹配，为同一手指的指纹。

